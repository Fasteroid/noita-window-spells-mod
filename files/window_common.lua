function FindCrossingProjectiles(tag) 
    local window_radius = 32
    local window_x, window_y, window_rotation = EntityGetTransform( GetUpdatedEntityID() )
    
    local entities_through_window = {}

    local projectiles = EntityGetWithTag("projectile")

    for i=1, #projectiles do
        local projectile = projectiles[i]

        if EntityHasTag(projectile, tag) then goto continue_1 end -- comment(Fasteroid): skip what's already gone through
        if EntityHasTag(projectile, "window") then goto continue_1 end -- no window self intersection

        local velocity = EntityGetFirstComponent(projectile, "VelocityComponent")
        
        if not velocity then goto continue_1 end

        local x2, y2 = EntityGetTransform(projectile)
        local x1, y1 = ComponentGetValue2(velocity, "mPrevPosition")

        if( x1 == 0 and y1 == 0 ) then -- comment(Fasteroid): physics objects are different
            local vx1, vy1 = ComponentGetValue2(velocity, "mPrevVelocity")
            x1 = x2 - vx1
            y1 = y2 - vy1
        end

        -- Below code generated by Claude, thanks Anthropic!

        -- Transform positions to window's local coordinate system
        -- Subtract window position to center on window
        local rel_x1, rel_y1 = x1 - window_x, y1 - window_y
        local rel_x2, rel_y2 = x2 - window_x, y2 - window_y
        
        -- Rotate coordinates to align with window's orientation
        local cos_rot = math.cos(-window_rotation)
        local sin_rot = math.sin(-window_rotation)
        
        local local_x1 = rel_x1 * cos_rot - rel_y1 * sin_rot
        local local_y1 = rel_x1 * sin_rot + rel_y1 * cos_rot
        
        local local_x2 = rel_x2 * cos_rot - rel_y2 * sin_rot
        local local_y2 = rel_x2 * sin_rot + rel_y2 * cos_rot

        -- Check if projectile crossed the window plane (x-axis in local coordinates)
        -- This means the sign of local_x changed between frames
        local crossed_plane = (local_x1 > 0 and local_x2 < 0) or (local_x1 < 0 and local_x2 > 0)
        
        if crossed_plane then

            -- Find the y-coordinate where the crossing occurred
            -- Linear interpolation to find exact crossing point
            local t = local_x1 / (local_x1 - local_x2)  -- Parameter where x = 0
            local crossing_y = local_y1 + t * (local_y2 - local_y1)
            
            -- Check if crossing happened within window bounds
            if math.abs(crossing_y) <= window_radius then
                table.insert(entities_through_window, projectile)
                EntityAddTag(projectile, tag) -- comment(Fasteroid): tag so we don't find it again
            end
        end

        ::continue_1::
    end
    
    return entities_through_window
end

function ComponentObjectEditValue2(component_id, object_name, field_name, modifier)
    local value = ComponentObjectGetValue2(component_id, object_name, field_name)
    value = modifier(value)
    ComponentObjectSetValue2(component_id, object_name, field_name, value)
end

function ComponentEditValue2(component_id, field_name, modifier)
    local value = ComponentGetValue2(component_id, field_name)
    value = modifier(value)
    ComponentSetValue2(component_id, field_name, value)
end
